#version 460 core
#extension GL_ARB_bindless_texture : require

layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(binding = 0, std430) readonly buffer probe_gbuffers
{
    samplerCube cubemaps[];
};

layout(binding = 1, std430) readonly buffer probe_positions
{
    vec3 positions[];
};

uniform int probe_height;
uniform int probe_width;
uniform int probe_depth;
uniform float spacing;
uniform vec3 origin;
layout(binding = 0, rgba32f) uniform image3D sh_texture;

uniform samplerCubeArray g_colors[3];
uniform samplerCubeArray g_norms[3];
uniform samplerCubeArray g_positions[3];
uniform samplerCubeArray g_orms[3];
uniform samplerCubeArray g_depths[3];

#define PI 3.1415926535897932384626433832795
#define MAX_LIGHTS 8
#define DIRECTIONAL 0
#define POINT 1

struct Light
{
    vec3 position;
    vec3 direction;
    vec3 color;
    float radius;
    float strength;
    int type;
};

uniform Light lights[MAX_LIGHTS];
uniform int num_lights = 0;

uint lcg(uint seed)
{
    return seed * 1664525u + 1013904223u;
}

float random_float(inout uint seed)
{
    seed = lcg(seed);
    return float(seed) / float(0xffffffffu);
}

float klemenVisibility(vec3 L, vec3 H)
{
    float LoH = dot(L, H);
    return 0.25 / (LoH * LoH);
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float distributionGGX(vec3 N, vec3 H, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return num / denom;
}

float geometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r * r) / 2.0;

    float num = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return num / denom;
}

float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);

    float ggx2 = geometrySchlickGGX(NdotV, roughness);
    float ggx1 = geometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

float shBasis(int l, int m, vec3 direction)
{
    if (l == 0 && m == 0) return 0.282095f; // Y00
    if (l == 1 && m == -1) return 0.488603f * direction.y; // Y1-1
    if (l == 1 && m == 0) return 0.488603f * direction.z; // Y10
    if (l == 1 && m == 1) return 0.488603f * direction.x; // Y11
    if (l == 2 && m == -2) return 1.092548f * direction.x * direction.y; // Y2-2
    if (l == 2 && m == -1) return 1.092548f * direction.y * direction.z; // Y2-1
    if (l == 2 && m == 0) return 0.315392f * (3.0f * direction.z * direction.z - 1.0f); // Y20
    if (l == 2 && m == 1) return 1.092548f * direction.x * direction.z; // Y21
    if (l == 2 && m == 2) return 0.546274f * (direction.x * direction.x - direction.y * direction.y); // Y22
    return 0.0f; // Default
}

vec4 PBR(int id, vec3 p)
{
//    const int samples = 256;
//    uint seed = uint(id);
//    vec4 accumlated_color = vec4(0.0);
//    for (int i = 0; i < samples; i++)
//    {
//        float u = random_float(seed);
//        float v = random_float(seed);
//
//        float theta = 2.0 * PI * u;
//        float phi = acos(2.0 * v - 1.0);
//
//        vec3 dir = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
//        vec4 sample_coords = vec4(dir, cubemap_index);
//
//
//        //PBR that thang
//        vec3 FragPos = texture(g_positions[texture_array_index], sample_coords).rgb;
//        vec4 albedo_texture = texture(g_colors[texture_array_index], sample_coords).rgba;
//        vec3 albedo = albedo_texture.rgb;
//        vec3 orm = texture(g_orms[texture_array_index], sample_coords).rgb;
//        float metallic = orm.r;
//        float roughness = orm.g;
//        float ao = orm.b + 0.2;
//        vec3 N = texture(g_norms[texture_array_index], sample_coords).rgb;
//
//        vec3 V = normalize(probe_position - FragPos).rgb;
//        vec3 R = reflect(-V, N);
//
//        vec3 F0 = vec3(0.04);
//        F0 = mix(F0, albedo, metallic);
//
//        vec3 Lo = vec3(0.0);
//        for (int j = 0; j < num_lights; j++)
//        {
//            vec3 L = vec3(0.0);
//            vec3 radiance = vec3(0.0);
//            if (lights[i].type == DIRECTIONAL)
//            {
//                L = normalize(-lights[i].direction);
//                radiance = lights[i].color;
//            }
//            else
//            {
//                L = normalize(lights[i].position - FragPos);
//                float distance = length(lights[i].position - FragPos);
//                float attenutation = 1.0 / (distance * distance);
//                radiance = lights[i].color * attenutation;
//            }
//            vec3 H = normalize(V + L);
//
//
//            float NDF = distributionGGX(N, H, roughness);
//            float G = geometrySmith(N, V, L, roughness);
//            vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
//
//            vec3 numerator = NDF * G * F;
//            float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
//            vec3 specular = numerator / denominator;
//
//            vec3 kS = F;
//            vec3 kD = vec3(1.0) - kS;
//            kD *= 1.0 - metallic;
//
//            float NdotL = max(dot(N, L), 0.0);
//            Lo += ((kD * albedo / PI + specular) * radiance * NdotL);
//        }
//
//        albedo *= Lo;
//        accumlated_color += vec4(albedo, 1.0);
//    }
//
//    accumlated_color = accumlated_color / float(samples);
//    accumlated_color.a = 1.0f;
//    return accumlated_color;
    return vec4(1.0f);
}

void main()
{
    uint id = gl_WorkGroupID.x;
    vec3 pos = positions[id];
    vec4 albedo = texture(cubemaps[id * 4 + 0], vec3(0.0)).rgba;
    vec3 normal = texture(cubemaps[id * 4 + 1], vec3(0.0)).rgb;
    vec3 position = texture(cubemaps[id * 4 + 2], vec3(0.0)).rgb;
    vec3 orm = texture(cubemaps[id * 4 + 2], vec3(0.0)).rgb;

//    uint seed = x + y + z;
//
//    uint index = x + probe_width * (y + probe_depth * z);
//    const int max_cubemaps_per_array = (2048 / 6);
//    uint texture_array_index = index / max_cubemaps_per_array;
//    uint cubemap_index = index % max_cubemaps_per_array;
//
//    float x_pos = float(x) * spacing;
//    float y_pos = float(y) * spacing;
//    float z_pos = float(z) * spacing;
//    vec3 probe_position = vec3(x_pos, y_pos, z_pos);
//    probe_position += origin;


    //generate an sh function for this color
//    imageStore(sh_texture, ivec3(gl_GlobalInvocationID.xyz), accumlated_color);
}