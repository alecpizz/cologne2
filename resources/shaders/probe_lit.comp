#version 460 core

layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

uniform int probe_height;
uniform int probe_width;
uniform int probe_depth;
uniform float spacing;
uniform vec3 origin;
layout(binding = 0, rgba32f) uniform image3D sh_texture;

uniform samplerCubeArray g_colors[3];
uniform samplerCubeArray g_norms[3];
uniform samplerCubeArray g_positions[3];
uniform samplerCubeArray g_orms[3];
uniform samplerCubeArray g_depths[3];

#define PI 3.1415926535897932384626433832795
#define MAX_LIGHTS 8
#define DIRECTIONAL 0
#define POINT 1

struct Light
{
    vec3 position;
    vec3 direction;
    vec3 color;
    float radius;
    float strength;
    int type;
};

uniform Light lights[MAX_LIGHTS];
uniform int num_lights = 0;

uint lcg(uint seed)
{
    return seed * 1664525u + 1013904223u;
}

float random_float(inout uint seed)
{
    seed = lcg(seed);
    return float(seed) / float(0xffffffffu);
}

float klemenVisibility(vec3 L, vec3 H)
{
    float LoH = dot(L, H);
    return 0.25 / (LoH * LoH);
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float distributionGGX(vec3 N, vec3 H, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return num / denom;
}

float geometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r * r) / 2.0;

    float num = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return num / denom;
}

float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);

    float ggx2 = geometrySchlickGGX(NdotV, roughness);
    float ggx1 = geometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

float shBasis(int l, int m, vec3 direction)
{
    if (l == 0 && m == 0) return 0.282095f; // Y00
    if (l == 1 && m == -1) return 0.488603f * direction.y; // Y1-1
    if (l == 1 && m == 0) return 0.488603f * direction.z; // Y10
    if (l == 1 && m == 1) return 0.488603f * direction.x; // Y11
    if (l == 2 && m == -2) return 1.092548f * direction.x * direction.y; // Y2-2
    if (l == 2 && m == -1) return 1.092548f * direction.y * direction.z; // Y2-1
    if (l == 2 && m == 0) return 0.315392f * (3.0f * direction.z * direction.z - 1.0f); // Y20
    if (l == 2 && m == 1) return 1.092548f * direction.x * direction.z; // Y21
    if (l == 2 && m == 2) return 0.546274f * (direction.x * direction.x - direction.y * direction.y); // Y22
    return 0.0f; // Default
}

void main()
{
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;
    uint seed = x + y + z;

    uint index = x + probe_width * (y + probe_depth * z);
    const int max_cubemaps_per_array = (2048 / 6);
    uint texture_array_index = index / max_cubemaps_per_array;
    uint cubemap_index = index % max_cubemaps_per_array;

    float x_pos = float(x) * spacing;
    float y_pos = float(y) * spacing;
    float z_pos = float(z) * spacing;
    vec3 probe_position = vec3(x_pos, y_pos, z_pos);
    probe_position += origin;

    const int samples = 256;
    vec4 accumlated_color = vec4(0.0);
    for (int i = 0; i < samples; i++)
    {
        float u = random_float(seed);
        float v = random_float(seed);

        float theta = 2.0 * PI * u;
        float phi = acos(2.0 * v - 1.0);

        vec3 dir = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
        vec4 sample_coords = vec4(dir, cubemap_index);


        //PBR that thang
        vec3 FragPos = texture(g_positions[texture_array_index], sample_coords).rgb;
        vec4 albedo_texture = texture(g_colors[texture_array_index], sample_coords).rgba;
        vec3 albedo = albedo_texture.rgb;
        vec3 orm = texture(g_orms[texture_array_index], sample_coords).rgb;
        float metallic = orm.r;
        float roughness = orm.g;
        float ao = orm.b + 0.2;
        vec3 N = texture(g_norms[texture_array_index], sample_coords).rgb;

        vec3 V = normalize(probe_position - FragPos).rgb;
        vec3 R = reflect(-V, N);

        vec3 F0 = vec3(0.04);
        F0 = mix(F0, albedo, metallic);

        vec3 Lo = vec3(0.0);
        for (int j = 0; j < num_lights; j++)
        {
            vec3 L = vec3(0.0);
            vec3 radiance = vec3(0.0);
            if (lights[i].type == DIRECTIONAL)
            {
                L = normalize(-lights[i].direction);
                radiance = lights[i].color;
            }
            else
            {
                L = normalize(lights[i].position - FragPos);
                float distance = length(lights[i].position - FragPos);
                float attenutation = 1.0 / (distance * distance);
                radiance = lights[i].color * attenutation;
            }

            float NdotL = max(dot(N, L), 0.0);
            Lo += (albedo * radiance * NdotL);
        }

//            vec4 shColor = vec4(0.0);
//            for (int l = 0; l <= 2; l++)
//            {
//                for (int m = -l; m <= l; m++)
//                {
//                    float basis = shBasis(l, m, dir);
//                    accumlated_color.r += color.r * basis;
//                    accumlated_color.g += color.g * basis;
//                    accumlated_color.b += color.b * basis;
//                }
//            }

        accumlated_color += vec4(albedo, 1.0);
    }

    accumlated_color = accumlated_color / float(samples);
    accumlated_color.a = 1.0f;
    //generate an sh function for this color
    imageStore(sh_texture, ivec3(gl_GlobalInvocationID.xyz), accumlated_color);
}